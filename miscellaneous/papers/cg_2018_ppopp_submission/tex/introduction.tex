\section{Introduction}
A \emph{data-race} is where two concurrent executions access the same memory location with at least one of the two accesses being a write. It introduces non-determinism into the program execution as the behavior may depend on the order in which the concurrent executions access memory. Data-race is problematic because it is not possible to directly control or observe the run-time internals to know if a data-race exists let alone enumerate program behaviors when one does.

The problem of \emph{Data-race detection}, given a program with its input, is to determine if there exists an execution containing a data-race. The research presented in this paper is concerned with data-race detection for \emph{task parallel models} that impose structure on parallelism by constraining how threads are created and joined, and by constraining how shared memory is accessed (e.g., Cilk, X10, Chapel, Habanero, etc.). These models rely on run-time environments to implement task abstractions to represent concurrent executions \cite{blumofe1996cilk,charles2005x10,cave2011habanero,imam2014habanero}. The language restrictions on parallelism and shared memory interactions enable properties like \emph{determinism} (i.e., the computation is independent of the execution) or the ability to \emph{serialize} (i.e., removing all task related keywords yields a serial solution). Such properties are predicated on the input programs being data-race free, which is not always the case since programmers, both intentionally and unintentionally, move outside the programming model.


Data-race detection in task parallel models generally prioritizes performance and the ability to scale to many tasks. The predominant \emph{SP-bags} algorithm, with its variants, exploits assumptions on task creation and joining for efficient on-the-fly detection with low overhead \cite{Feng1997EDD258492258493,Cheng1998DDR277651277696,Bender2004OMS10079121007933,Async-Finish-Race,Utterback2016PGP29357642935801}; millions of tasks are feasible with varying degrees of slow-down (i.e., slow-down increases as parallelism constraints are relaxed) \cite{drdForFutures,Surendran2016}. Other approaches use access histories \cite{mellor1991fly,raman2012scalable} or programmer annotations \cite{westbrook2012practical, westbrook2012permission}.
Performance is a priority, and many solutions are only \emph{complete}, meaning that nothing can be concluded about other executions of the same program.

The research presented in this paper reprises data-race detection in task parallel models in the context of model checking under two assumptions: first, data-race is largely independent of the size of the problem instance; and second, it is possible to instantiate small problem instances. These assumptions are indeed implicit in other model checking solutions for task parallel models---a small problem instance is the best solution to state explosion \cite{gligoric2012x10x,zirkel2013automated,anderson2014jpf}. Prior approaches, however, extensively modify the language run-time and the model checker. Such solutions require source code \cite{gligoric2012x10x}, sometimes require the user to specify the number of processors modeled making it difficult to generalize \cite{zirkel2013automated}, or rely on user annotations to indicate sharing so data-race may be missed \cite{anderson2014jpf}. The solution here is to make clear the requirements on the run-time, use semantics that are independent of actual hardware, and automatically detect data-race without annotations. 

The approach first defines a \emph{computation graph} to abstractly model parallelism with a naive algorithm to detect data-race. Computation graph construction is then formally defined in a general task parallel model based on partitioning concurrent executions into hierarchical regions with shared locations. Such a model is suitable to describe real-world languages (e.g., Cilk, X10, Chapel, Habanero, etc.).  A fragment of the model is then defined so that data-race detection on a computation graph from a single execution is both sound and complete (e.g., and single trace is sufficient to prove the absence of data-race in all execution schedules). Any approach that only allows programs in the deterministic fragment of the language is able to make similar guarantees. The deterministic fragment is then expanded to show how model checking may be applied to enumerate the space of computation graphs for data-race detection. Finally, the approach is evaluated on a Java implementation of Habenero with the Java Pathfinder model checker (JPF). Results over several published benchmarks comparing to JPF's default race detection using partial order reduction and a task parallel approach with permission regions show the computation graph approach to be more efficient in JPF terms with its overhead. The primary contributions are thus
\begin{compactitem}
\item a simple approach to data-race detection based on constructing a computation graph from an execution of a task parallel program;
\item the computation graph construction in terms of general semantics suitable for real-world languages;
\item a scheduling algorithm for model checking when a programmer uses mutual exclusion (e.g., a way to enumerate all possible computation graphs); and
\item an implementation of the approach for Java Habanero in JPF with results from benchmarks comparing to other solutions in JPF. 
\end{compactitem}
