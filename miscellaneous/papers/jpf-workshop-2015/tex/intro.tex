\section{Introduction}
The increasing use of multicore processors is motivating the use of parallel programming. However, it is very difficult to write concurrent programs that are free from bugs. When programs execute different instructions simultaneously, different thread schedules and memory access patterns are observed that give rise to various issues such as data-races, deadlocks etc. To make writing concurrent programs easier, Rice University developed Habanero Java Programming model \cite{Cave:2011:HNA:2093157.2093165}. It provides safety guarantees such as deadlock freedom, deterministic output and serialization for subsets of constructs provided in the programming model. These guarantees hold only in the absence of data-races. The Habanero Java library (HJ-Lib) \cite{hj-lib} is a Java 8 library implementation of the Habanero Java programming model.

VR-lib \cite{Anderson:2015:JVH:2693208.2693245}, a verification runtime for HJ programs was built at Brigham Young University. VR-lib facilitates the verification of HJ programs using JPF. VR-lib can be used along with JPF to build computation graphs of HJ programs. A Computation Graph (CG) is an acyclic directed graph that consists of a set of nodes, where each node represents a step consisting of some sequential execution of the program and a set of edges that represent the ordering of the steps. A CG stores the memory locations accessed and updated by each of the operators. It also correctly reflects the control flow structure of the program.

The CGRaceDetector listener presented in this work monitors the various object creations and destructions, instruction executions etc to build a computation graph for the HJ program under a single schedule. It later analyzes this graph to verify any data access violations to report data races. For structurally deterministic programs, verifying the HJ program under a single schedule is enough to detect data races.

Section 2 of this paper presents an overview of the Habanero Java programming model and gives a brief description for the various parallel constructs of HJ language. Section 3 describes the computation graphs and its various elements. It also gives the implementation details of computation graph builder and analyzer for HJ programs created with the help of JPF. Section 4 describes the preliminary results of the CGRaceDetector on some HJ micro-benchmarks. Section 5 concludes and outlines the ways to  extend this work.
