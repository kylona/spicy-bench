Data-race detection is the problem of determining if a concurrent program has a data-race in some execution and input; it has been long studied and often solved for different contexts and goals. The research in this paper reprises the problem of data-race detection but in the context of model checking as opposed to run-time monitoring or static analysis. The programming model is task parallel where computations are hierarchically divided into non-isolated parallel executing tasks and is suitable to describing real-world languages (i.e., Cilk, X10, Chapel, Habanero, etc.). The model semantics are defined to construct a computation graph and a naive algorithm to detect data-race on a computation graph is given. A fragment of the programming model is defined such that the algorithm becomes sound and complete for computation graphs from a single observed program execution. Model checking is applied to programs outside this fragment to enumerate all possible computation graphs. The approach is evaluated in a Java implementation of Habanero using the JavaPathfinder model checker. The results, when compared to existing data-race detectors in Java Pathfinder, show a significant reduction in the time required for data race detection.

\begin{comment}
Task parallel programming languages provide a way for creating asynchronous tasks that can run concurrently. The advantage of using task parallelism is that the programmer can write code that is independent of the underlying hardware. The runtime determines the number of processor cores that are available and the most efficient way to execute the tasks. When two or more concurrently executing tasks access a shared memory location and if at least one of the accesses is for writing, data race is observed in the program. Data races can introduce non-determinism in the program output making it important to have data race detection tools. To detect data races in task parallel programs, a new sound and complete technique based on computation graphs is presented in this work. The data race detection algorithm runs in $\mathcal{O}$(N$^2$) time where N is number of nodes in the graph. A computation graph is a directed acyclic graph that represents the execution of the program. For detecting data races, the computation graph stores shared heap locations accessed by the tasks. An algorithm for creating computation graphs augmented with memory locations accessed by the tasks is also described here. This algorithm runs in $\mathcal{O}$(N) time where N is the number of operations performed in the tasks. A scheduling algorithm that creates all possible computation graph structures for programs containing critical sections is also presented here. This work also presents an implementation of this technique for the Java implementation of the Habanero programming model. The results of this data race detector are compared to Java Pathfinder's precise race detector extension and permission regions based race detector extension. The results show a significant reduction in the time required for data race detection using this technique.

Cut from current abstract

A data-race is where two concurrent executions access the same memory location with at least one of the two accesses being a write. A data-race introduces non-determinism in program execution complicating both test and debug since the programmer is not able to directly control or observe the internals of the the execution run-time. The computation graph captures the partial-order between tasks with memory references. 
\end{comment}
